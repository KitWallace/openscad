declare variable $local:db := concat("/db/",substring-after(system:get-module-load-path(),"/db/"),"/");
declare variable $local:solids := doc("/db/apps/3d/grouped-solids.xml");

declare option exist:serialize "method=text media-type=text/text";

declare function local:parse-text($meta) {
  let $url := concat("http://dmccooey.com/polyhedra/",$meta/id,".txt")
  let $doc := httpclient:get(xs:anyURI($url),false(),())/httpclient:body
  let $doc := util:unescape-uri($doc,"UTF-8")
  let $lines := tokenize($doc,"&#10;")
 (:  let $name := $lines[1] :)   (: bug -  actually can be multiple lines  :)
  let $vars :=
      for $vline in $lines[starts-with(.,"C")]  
      let $parts := tokenize($vline," = ")
      let $name := $parts[1]
      let $value := normalize-space($parts[2])
      where matches($value,"^(\d|\.)+$")    (: only constant values, not formula :)
      return 
           element var {
                element name {$name},
                element value {$value}
          }
   let $points := 
     for $pline in $lines[starts-with(.,"V")]
     let $parts := tokenize($pline," = ") 
     let $xyz := replace(replace($parts[2],"\(",""),"\)","")
     return  
          element point {$xyz}
   let $faces := 
      for $fline in $lines[starts-with(.,"{")]
      let $list := substring-after(substring-before($fline,"}"),"{")
      let $list := string-join(reverse(tokenize($list,",")),",")
      return
          element face {$list}
   let $edges :=
      let $raw_edges := 
         for $faces in $faces
         let $vertices := tokenize($faces,",")
         let $n := count($vertices)
         return
           for $i in (1 to $n)
           let $j :=  if ($i < $n) then $i + 1 else 1
           let $v0 := xs:integer($vertices[$i])
           let $v1 := xs:integer($vertices[$j])
           return concat(min(($v0,$v1)),",",max(($v0,$v1)))
      for $edge in distinct-values($raw_edges)
          return 
            element edge {$edge}

  return 
    element solid {
        $meta/id,
        element url {$url},
        element name {$meta/name},
        element vars {$vars},
        element points {$points},
        element faces {$faces},
        element edges {$edges}
    }
};


declare function local:parse-vrml($meta) {
  let $doc := httpclient:get(xs:anyURI($meta/url),false(),())/httpclient:body
  let $text := util:binary-to-string($doc)
  let $rdoc := concat("<text>",replace(replace($text,"\}","</div>"),"\{","<div>"),"</text>")
  let $xml := util:parse($rdoc)/text/div

  let $points := 
       let $d := $xml/div[contains(.,"point [")]
       let $data:= substring-before(substring-after($d,"point ["),"]")
       for $s in tokenize($data,",")
       let $sn :=normalize-space($s)
       where $sn != ""
       return  
                element point { replace($sn," ",",") }
  let $faces := 
       for $d in $xml/div[contains(.,"coordIndex [")]
       let $data := substring-before(substring-after($d,"coordIndex ["),"]")
       for $face in tokenize($data,",-1,")
       let $indexes := tokenize(normalize-space($face),",")
       where count($indexes) > 2
       return  element face {string-join(reverse($indexes),",")}
  let $edges :=
      let $raw_edges := 
         for $faces in $faces
         let $vertices := tokenize($faces,",")
         let $n := count($vertices)
         return
           for $i in (1 to $n)
           let $j :=  if ($i < $n) then $i + 1 else 1
           let $v0 := xs:integer($vertices[$i])
           let $v1 := xs:integer($vertices[$j])
           return concat(min(($v0,$v1)),",",max(($v0,$v1)))
      for $edge in distinct-values($raw_edges)
          return 
            element edge {$edge}
    
  return 
     <solid>  
       {$meta/id},
       {$meta/name},
       {$meta/url},
       {element points {$points}},
       {element faces {$faces}},
       {element edges {$edges}}
     </solid>
};

declare function local:solid_to_openscad($solid) {
  string-join(
    ("// base coordinates",

     concat ("// source:  ", $solid/url),
     "// generated by  http://kitwallace.co.uk/3d/solid-to-scad.xq",
     concat('Name = "',$solid/name,'";'),
     for $var in $solid/vars/var
        return concat ($var/name, " = ", $var/value, ";"),
     concat("points = [&#10;",
          string-join(
              for $point in $solid/points/point
              return concat("[",$point,"]")
              ,",&#10;")
              , "];"),
     concat("faces = [&#10;",
            string-join(
              for $face in $solid/faces/face
              return concat("[",$face,"]")
              ,",&#10;")
              , "];"),
     concat("edges = [&#10;",
            string-join(
              for $edge in $solid/edges/edge
              return concat("[",$edge,"]")
              ,",&#10;")
              , "];"),
    "// --------------------------------- ",
     ""
    ),"&#10;"
    )
};

let $id:= request:get-parameter("id",())
let $base := request:get-parameter("base",$id)
let $scad_file := request:get-parameter("scad","wire")
let $meta := $local:solids//solid[id=$id]
let $metabase := $local:solids//solid[id=$base]
let $action := request:get-parameter("action","form")
return
  if($action="form")
  then 
     let $serialize := util:declare-option("exist:serialize", "format=xhtml media-type=text/html")
     return
  <html>
     <head>
       <title>Polyhedra to OpenSCAD</title>
     </head>
     <body>
        <h2>{$meta/name/string()}</h2>
         <form action="?">
          Solid id <input type="text" name="id" value="{$id}" />  
          Base <input type="text" name="base" value="{$base}" />
          OpenSCAD <select name="scad">
                      {for $s in ("shell","wire","stellate","antistellate")
                       return
                         element option {
                             attribute value {$s},
                             if ($s = $scad_file) then attribute selected {"selected"} else (),
                             $s
                         }
                      }
                   </select>
           <input type="submit" name="action" value="Generate OpenSCAD"/>
        </form>
        <div> <a href="solid-index.xq">Polyhedra index</a></div>

     </body>
 </html>
     
else

let $solid :=  if ($metabase/url) then local:parse-vrml($metabase)  else local:parse-text($metabase)
let $construct := $meta/construct[scad=$scad_file]
let $scad_main := util:binary-to-string(util:binary-doc(concat($local:db,"openscad/",$scad_file,".scad")))
let $scad_main2 :=  if ($construct/code) then replace($scad_main,"//insert",$construct/code) else $scad_main
let $scad_functions := util:binary-to-string(util:binary-doc(concat($local:db,"openscad/functions.scad")))
let $openscad := if($solid) 
                 then
                    string-join((
                     concat("// ",$solid/name),
                     local:solid_to_openscad($solid),
                     $scad_main2,
                     $scad_functions
                    ),"&#10;&#10;"
                    )
                 else             
()
(: let $serialize := util:declare-option("exist:serialize", "format=text media-type=text/text"):)
let $header := response:set-header('content-disposition', concat("attachment; filename=",$id,".scad")) 
return
  if ($scad_main)
  then $openscad
  else ()
